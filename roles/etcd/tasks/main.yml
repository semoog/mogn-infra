---

# => checks

- name: check etcd version
  shell: "etcd --version | grep {{ ETCD_VERSION }}"
  register: etcd_version_match
  changed_when: False
  ignore_errors: yes

- name: check for existing cert
  stat:
    path: "{{ playbook_dir }}/certs/ca.pem"
  register: cacert
  delegate_to: 127.0.0.1

- name: check for existing node cert
  stat:
    path: "{{ playbook_dir }}/certs/{{ inventory_hostname }}.pem"
  register: node_etcd_cert
  delegate_to: 127.0.0.1

- name: check for existing server key
  stat:
    path: /etc/etcd/server.key
  register: node_etcd_server_key

# => installing etcd (if it isn't installed or our version doesn't match)

- import_tasks: install-etcd.yml
  when: etcd_version_match.rc != 0

# => setting up certs

- name: create local directory for cert storage
  file:
    path: "{{ playbook_dir }}/certs"
    state: directory
  delegate_to: 127.0.0.1

- name: create the CA certificate to be used by all the etcd servers and clients
  shell: "cd {{ playbook_dir }}/certs && echo '{\"CN\":\"CA\",\"key\":{\"algo\":\"rsa\",\"size\":2048}}' | cfssl gencert -initca - | cfssljson -bare ca -"
  delegate_to: 127.0.0.1
  when: not cacert.stat.exists

- name: create the CA certificate to be used by all the etcd servers and clients part 2
  shell: "cd {{ playbook_dir }}/certs && echo '{\"signing\":{\"default\":{\"expiry\":\"43800h\",\"usages\":[\"signing\",\"key encipherment\",\"server auth\",\"client auth\"]}}}' > ca-config.json"
  delegate_to: 127.0.0.1
  when: not cacert.stat.exists

- name: create the CA certificate to be used by each node in the cluster
  shell: "cd {{ playbook_dir }}/certs && echo '{\"CN\":\"'{{ inventory_hostname }}'\",\"hosts\":[\"\"],\"key\":{\"algo\":\"rsa\",\"size\":2048}}' | cfssl gencert -config=ca-config.json -ca=ca.pem -ca-key=ca-key.pem -hostname=\"{{ hostvars[inventory_hostname].ip }},{{ inventory_hostname }}\" - | cfssljson -bare {{ inventory_hostname }}"
  delegate_to: 127.0.0.1
  when: not node_etcd_cert.stat.exists

- name: create node directory for etcd certs
  file:
    path: /etc/etcd
    state: directory
    owner: root
    group: root
    mode: 0700

- name: copy CA cert to node etcd directory
  copy:
    src: "{{ playbook_dir }}/certs/ca.pem"
    dest: "/etc/etcd/etcd-ca.crt"
    owner: root
    group: root
    mode: 0600

- name: copy node server cert to node etcd directory
  copy:
    src: "{{ playbook_dir }}/certs/{{ inventory_hostname }}.pem"
    dest: "/etc/etcd/server.crt"
    owner: root
    group: root
    mode: 0600

- name: take ownership of server key file (so we can copy it out to the node)
  file:
    path: "{{ playbook_dir }}/certs/{{ inventory_hostname }}-key.pem"
    owner: root
    group: root
    mode: 0755 # yeah I know
  delegate_to: 127.0.0.1
  # when: not node_etcd_server_key.stat.exists

- name: copy node server key to node etcd directory
  copy:
    src: "{{ playbook_dir }}/certs/{{ inventory_hostname }}-key.pem"
    dest: "/etc/etcd/server.key"
    owner: root
    group: root
    mode: 0600
  # notify: cleanup-etcd-certs

# => configuring and starting etcd  

- name: create list of nodes to be added into the cluster
  set_fact: etcd_nodelist={%for host in groups['servers']%}{{hostvars[host].inventory_hostname}}=https://{{hostvars[host].ip}}:2380{% if not loop.last %},{% endif %}{% endfor %}

- name: create etcd.conf on node
  template:
    src: templates/etcd.conf.j2
    dest: /etc/etcd/etcd.conf
    owner: root
    group: root
    mode: 0644

- name: create etcd service
  template: 
    src: templates/etcd.service.j2 
    dest: /lib/systemd/system/etcd.service 
    mode: 0644
  notify: systemctl-daemon-reload

# forces the handler (systemctl-daemon-reload) to run immediately
# instead of at the end of the play
- meta: flush_handlers

- name: enable / start etcd service
  service: name=etcd.service state=started enabled=yes

- name: check etcd service health
  shell: "curl --cacert /etc/etcd/etcd-ca.crt --cert /etc/etcd/server.crt --key /etc/etcd/server.key https://{{ hostvars[inventory_hostname].ip }}:2379/health"
  register: etcd_health_cmd
  changed_when: False

- set_fact: 
    etcd: "{{ etcd_health_cmd.stdout | from_json }}"

- block:
    - name: "end play if etcd is unhealthy"
      debug:
        msg: "!! etcd is unhealthy, manual intervention required. Ending play !!"

    - meta: end_play
  when: etcd.health == 'false'
